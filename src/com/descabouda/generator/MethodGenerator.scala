package com.descabouda.generator

import com.descabouda.models._

class MethodGenerator {
  final val ACC_PUBLIC: Short = 0x0001	      // Declared public; may be accessed from outside its package.
  final val ACC_PRIVATE: Short = 0x0002	      // Declared private; accessible only within the defining class.
  final val ACC_PROTECTED: Short = 0x0004	    // Declared protected; may be accessed within subclasses.
  final val ACC_STATIC: Short = 0x0008	      // Declared static.
  final val ACC_FINAL: Short = 0x0010	        // Declared final; must not be overridden.
  final val ACC_SYNCHRONIZED: Short = 0x0020  // Declared synchronized; invocation is wrapped by a monitor use.
  final val ACC_BRIDGE: Short = 0x0040	      // A bridge method, generated by the compiler.
  final val ACC_VARARGS: Short = 0x0080	      // Declared with variable number of arguments.
  final val ACC_NATIVE: Short = 0x0100	      // Declared native; implemented in a language other than Java.
  final val ACC_ABSTRACT: Short = 0x0400	    // Declared abstract; no implementation is provided.
  final val ACC_STRICT: Short = 0x0800	      // Declared strictfp; floating-point mode is FP-strict.
  final val ACC_SYNTHETIC: Short = 0x1000	    // Declared synthetic; not present in the source code.

  def generate(baseClass: BaseClass, method: BaseMethod): OutputMethod = {
    val outputMethod = new OutputMethod()

    outputMethod.publicFlag = (method.accessFlags & ACC_PUBLIC) == ACC_PUBLIC
    outputMethod.privateFlag = (method.accessFlags & ACC_PRIVATE) == ACC_PRIVATE
    outputMethod.protectedFlag = (method.accessFlags & ACC_PROTECTED) == ACC_PROTECTED
    outputMethod.staticFlag = (method.accessFlags & ACC_STATIC) == ACC_STATIC
    outputMethod.finalFlag = (method.accessFlags & ACC_FINAL) == ACC_FINAL
    outputMethod.synchronizedFlag = (method.accessFlags & ACC_SYNCHRONIZED) == ACC_SYNCHRONIZED
    outputMethod.bridgeFlag = (method.accessFlags & ACC_BRIDGE) == ACC_BRIDGE
    outputMethod.varArgsFlag = (method.accessFlags & ACC_VARARGS) == ACC_VARARGS
    outputMethod.nativeFlag = (method.accessFlags & ACC_NATIVE) == ACC_NATIVE
    outputMethod.abstractFlag = (method.accessFlags & ACC_ABSTRACT) == ACC_ABSTRACT
    outputMethod.strictFlag = (method.accessFlags & ACC_STRICT) == ACC_STRICT
    outputMethod.syntheticFlag = (method.accessFlags & ACC_SYNTHETIC) == ACC_SYNTHETIC

    if (method.nameIndex > 0)
      outputMethod.name = baseClass.getUtf8(method.nameIndex - 1)

    if (method.descriptorIndex > 0)
      outputMethod.descriptor = baseClass.getUtf8(method.descriptorIndex - 1)

    generateAttributes(baseClass, method, outputMethod)
    outputMethod
  }

  def generateAttributes(baseClass: BaseClass, baseMethod: BaseMethod, method: OutputMethod): Unit = {
    val attributeGenerator = new AttributeGenerator()
    baseMethod.attributes.forEach((attribute) => {
      val outputAttribute = attributeGenerator.generate(baseClass, attribute)
      method.attributes += outputAttribute.name -> outputAttribute
    })
  }
}
